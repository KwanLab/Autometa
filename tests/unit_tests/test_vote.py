import pytest

from autometa.taxonomy import vote
from autometa.taxonomy.ncbi import NCBI

import pandas as pd


@pytest.fixture(name="blastp")
def fixture_blastp(variables, tmp_path):
    """diamond blastp output fixture

    Parameters
    ----------
    variables : dict
        Imported from test_data.json (See pytest.ini for reference to file path).
        test_data.json is generated by make_test_data.py
    tmp_path : Pathlib.Path
        temporary path constructed by pytest

    Returns
    -------
    str
        diamond blastp output file path written from `variables["taxonomy"]`
    """
    vote_test_data = variables["taxonomy"]
    blastp_fpath = tmp_path / "blastp.tsv"
    df = pd.read_json(vote_test_data["blastp"])
    df.to_csv(blastp_fpath, sep="\t", index=False, header=False)
    return blastp_fpath.as_posix()


@pytest.fixture(name="prot_orfs")
def fixture_prot_orfs(variables, tmp_path):
    """Amino-acid orfs corresponding to diamond blastp output table.
    This is required for translation of query ORFs back to contigs.

    Parameters
    ----------
    variables : dict
        Imported from test_data.json (See pytest.ini for reference to file path).
        test_data.json is generated by make_test_data.py
    tmp_path : Pathlib.Path
        temporary path constructed by pytest

    Returns
    -------
    str
        amino-acid ORFs file path
    """
    vote_test_data = variables["taxonomy"]
    records = vote_test_data["prot_orfs"]
    lines = ""
    for record, seq in records.items():
        lines += f"{record}\n{seq}\n"
    fpath = tmp_path / "orfs.faa"
    with open(fpath, "w") as fh:
        fh.write(lines)
    return fpath.as_posix()


@pytest.fixture(name="dbdir")
def fixture_dbdir(tmpdir):
    """temporary NCBI database directory

    Parameters
    ----------
    tmpdir : Pathlib.LocalPath
        pytest generated temporary directory

    Returns
    -------
    Pathlib.LocalPath
        Path to temporary NCBI database directory
    """
    tmpdir.mkdir("ncbi")
    return tmpdir / "ncbi"


@pytest.fixture(name="nodes")
def fixture_nodes(variables, dbdir):
    """Lines corresponding to nodes.dmp

    Parameters
    ----------
    variables : [type]
        [description]
    dbdir : pytest fixture
        [description]

    Returns
    -------
    [type]
        [description]
    """
    vote_test_data = variables["taxonomy"]
    lines = ""
    for child, info in vote_test_data["nodes"].items():
        # Parsing in ncbi.parse_nodes() follows NCBI nodes.dmp file format.
        # child, parent, rank = line.split("\t|\t")[:3]
        parent = info.get("parent")
        rank = info.get("rank")
        child, parent, rank = [str(i) for i in [child, parent, rank]]
        lines += "\t|\t".join([child, parent, rank, "null"]) + "\n"
    return lines


@pytest.fixture(name="names")
def fixture_names(variables, dbdir):
    vote_test_data = variables["taxonomy"]
    lines = ""
    for taxid, name in vote_test_data["names"].items():
        # Parsing in ncbi.parse_names() follows NCBI names.dmp file format.
        # taxid, name, __, classification = line.strip("\t|\n").split("\t|\t")[:4]
        # scientific name is checked with classification variable.
        lines += (
            "\t|\t".join([taxid, name, "null", "scientific name", "null"]) + "\t|\n"
        )
        # lines follows structure of names.dmp database.
    return lines


@pytest.fixture(name="merged")
def fixture_merged(variables, dbdir):
    vote_test_data = variables["taxonomy"]
    # Parsing in ncbi.parse_merged() follows NCBI merged.dmp file format.
    lines = ""
    for old_taxid, new_taxid in vote_test_data["merged"].items():
        # old_taxid, new_taxid = line.strip("\t|\n").split("\t|\t")
        lines += f"{old_taxid}\t|\t{new_taxid}\t|\n"
    return lines


@pytest.fixture(name="acc2taxid")
def fixture_acc2taxid(variables, dbdir):
    vote_test_data = variables["taxonomy"]
    # Parsing in diamond.add_taxids(...) follows NCBI prot.accession2taxid file format.
    lines = "accession\taccession.version\ttaxid\tnull\n"
    for acc_num, taxid in vote_test_data["acc2taxid"].items():
        # acc_num, acc_ver, taxid, _ = line.split("\t")
        lines += f"{acc_num}\tnull\t{taxid}\tnull\n"
    return lines


@pytest.fixture(name="ncbi_dir")
def fixture_ncbi(dbdir, merged, nodes, names, acc2taxid):
    # NOTE: NCBI instance expects file name prot.accession2taxid
    acc2taxid_fpath = dbdir / "prot.accession2taxid"
    # NOTE: NCBI instance expects file name merged.dmp
    merged_fpath = dbdir / "merged.dmp"
    # NOTE: NCBI instance expects file name names.dmp
    names_fpath = dbdir / "names.dmp"
    # NOTE: NCBI instance expects file name nodes.dmp
    nodes_fpath = dbdir / "nodes.dmp"
    for fpath, data in zip(
        [merged_fpath, nodes_fpath, names_fpath, acc2taxid_fpath],
        [merged, nodes, names, acc2taxid],
    ):
        fpath.write(data)
    return dbdir


@pytest.fixture(name="votes")
def fixture_votes():
    votes = [
        {"contig": "NODE_1_length_1389215_cov_225.275", "taxid": 373},
        {"contig": "NODE_2_length_1166739_cov_224.155", "taxid": 60890},
    ]
    return pd.DataFrame(votes).set_index("contig")


def test_add_ranks(ncbi_dir, votes, tmp_path):
    ncbi = NCBI(dirpath=ncbi_dir, verbose=False)
    out = tmp_path / "taxonomy.ranks_added.tsv"
    df = vote.add_ranks(df=votes, outfpath=out, ncbi=ncbi)
    assert df.shape == (2, 8)
    assert df.index.name == "contig"
    canonical_ranks = {rank for rank in ncbi.CANONICAL_RANKS if rank != "root"}
    for canonical_rank in canonical_ranks:
        assert canonical_rank in df.columns


@pytest.mark.slow
def test_vote_assign(blastp, ncbi_dir, prot_orfs, tmp_path):
    out = tmp_path / "votes.tsv"
    votes = vote.assign(
        outfpath=out, prot_orfs=prot_orfs, blast=blastp, ncbi_dir=ncbi_dir,
    )
    assert isinstance(votes, pd.DataFrame)
    assert votes.index.name == "contig"
    # assert votes.shape == (..., 2)


@pytest.mark.skip
@pytest.mark.wip
def test_vote_get(ncbi_dir):
    fpath = ""
    assembly = ""
    kingdom = ""
    outdir = ""
    vote.get(
        fpath=fpath,
        assembly=assembly,
        kingdom=kingdom,
        ncbi_dir=ncbi_dir,
        outdir=outdir,
    )
